<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>AAYUSHYA TIWARI</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="code: from source to execution
do you know how your code
int f(){
    return 42;
}
turns into
mov eax, 42
ret
and then into
B8 2A 00 00 00 C3
this?

Here’s the whole essay in short:
source code → something happens, Intermediate code forms → something happens again, Machine code is formed.
We’ll clear the ‘something’ in this article.

Life would be very simple if we humans could write 1s and 0s and directly give machine it’s prefered machine code. But since we don’t have 1000 hands per person and the outputs that we’re expecting out of computers have evolved to complexities unimaginable, we need another simpler way to talk to the machines. And that is why we have different programming languages and their compilation processes.">
    <meta name="generator" content="Hugo 0.154.5">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/code-from-source-to-execution/code-from-source-to-execution/">
    

    
    
    <meta property="og:url" content="http://localhost:1313/posts/code-from-source-to-execution/code-from-source-to-execution/">
  <meta property="og:site_name" content="AAYUSHYA TIWARI">
  <meta property="og:title" content="AAYUSHYA TIWARI">
  <meta property="og:description" content="code: from source to execution do you know how your code
int f(){ return 42; } turns into
mov eax, 42 ret and then into
B8 2A 00 00 00 C3
this?
Here’s the whole essay in short:
source code → something happens, Intermediate code forms → something happens again, Machine code is formed.
We’ll clear the ‘something’ in this article.
Life would be very simple if we humans could write 1s and 0s and directly give machine it’s prefered machine code. But since we don’t have 1000 hands per person and the outputs that we’re expecting out of computers have evolved to complexities unimaginable, we need another simpler way to talk to the machines. And that is why we have different programming languages and their compilation processes.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">

  <meta itemprop="name" content="AAYUSHYA TIWARI">
  <meta itemprop="description" content="code: from source to execution do you know how your code
int f(){ return 42; } turns into
mov eax, 42 ret and then into
B8 2A 00 00 00 C3
this?
Here’s the whole essay in short:
source code → something happens, Intermediate code forms → something happens again, Machine code is formed.
We’ll clear the ‘something’ in this article.
Life would be very simple if we humans could write 1s and 0s and directly give machine it’s prefered machine code. But since we don’t have 1000 hands per person and the outputs that we’re expecting out of computers have evolved to complexities unimaginable, we need another simpler way to talk to the machines. And that is why we have different programming languages and their compilation processes.">
  <meta itemprop="wordCount" content="1250">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="AAYUSHYA TIWARI">
  <meta name="twitter:description" content="code: from source to execution do you know how your code
int f(){ return 42; } turns into
mov eax, 42 ret and then into
B8 2A 00 00 00 C3
this?
Here’s the whole essay in short:
source code → something happens, Intermediate code forms → something happens again, Machine code is formed.
We’ll clear the ‘something’ in this article.
Life would be very simple if we humans could write 1s and 0s and directly give machine it’s prefered machine code. But since we don’t have 1000 hands per person and the outputs that we’re expecting out of computers have evolved to complexities unimaginable, we need another simpler way to talk to the machines. And that is why we have different programming languages and their compilation processes.">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        AAYUSHYA TIWARI
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/posts/" title="Writings page">
              Writings
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1"></h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><h1 id="code-from-source-to-execution">code: from source to execution</h1>
<p>do you know how your code</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>turns into</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">mov</span> <span style="color:#960050;background-color:#1e0010">ea</span><span style="color:#66d9ef">x</span>, <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ret</span>
</span></span></code></pre></div><p>and then into</p>
<p><code>B8 2A 00 00 00 C3</code></p>
<p>this?</p>
<!-- raw HTML omitted -->
<p>Here’s the whole essay in short:</p>
<p><strong>source code</strong> → something happens, <strong>Intermediate code</strong> forms → something happens again, <strong>Machine code</strong> is formed.</p>
<p>We’ll clear the ‘something’ in this article.</p>
<!-- raw HTML omitted -->
<p>Life would be very simple if we humans could write 1s and 0s and directly give machine it’s prefered machine code. But since we don’t have 1000 hands per person and the outputs that we’re expecting out of computers have evolved to complexities unimaginable, we need another simpler way to talk to the machines. And that is why we have different programming languages and their compilation processes.</p>
<p>There are <strong>compiled languages</strong> and <strong>interpreted languages</strong> divided on the basis of when the code is executed.</p>
<p>Compiled languages are programming languages that are converted into machine code by the compiler and only then, is there an <em>executable file.</em></p>
<p>Interpreted languages are not converted into compiled code, rather the source code is directly executed line-by-line by the interpretor.</p>
<hr>
<p>CAVEAT: most of the lanugages today use a mixture of the two ideas. Ex. Initially, the <strong>JVM interprets the Java bytecode</strong> produced by the Java compiler, executing it instruction by instruction until it identifies frequently executed (“hot”) code paths, which are then compiled into native machine code by the JIT compiler for faster execution.</p>
<hr>
<h1 id="different-representations-of-the-code">Different representations of the code</h1>
<h2 id="source-code">Source code</h2>
<blockquote>
<p>This is the code that the programmer sees. It’s in programming languages.</p>
</blockquote>
<blockquote>
<p>Ex: .py files for Python code and .c files for C code.</p>
</blockquote>
<blockquote>
<p>it’s human-readable.</p>
</blockquote>
<blockquote>
<p>code has semantics (meaning) and a form.</p>
</blockquote>
<blockquote>
<p>features like comments, indentation and format.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Details on Structure</strong>:</p>
<ul>
<li><strong>Declarations</strong>: Define types and variables (e.g., int a).</li>
<li><strong>Expressions</strong>: Computations like a + b.</li>
<li><strong>Statements</strong>: Control flow like return.</li>
<li><strong>Modules/Files</strong>: Organized into files with includes/imports for modularity.</li>
</ul>
<h2 id="ir-intermediate-representation">IR: Intermediate Representation</h2>
<blockquote>
<p>It is the intermediate code that is formed.</p>
</blockquote>
<blockquote>
<p>it is a little bit more lower-level. Hence it forms a key phase in compiler’s front-end.</p>
</blockquote>
<blockquote>
<p>It is platform independent. Which enhances portability.</p>
</blockquote>
<blockquote>
<p>For n languages and m targets, you need n front-ends + m back-ends instead of n*m full compilers.</p>
</blockquote>
<blockquote>
<p>Intermediate code has several levels before the code turns into machine code:</p>
</blockquote>
<ul>
<li>
<p>high-level - ex: Syntax Tree</p>
<ul>
<li>
<p>close to source code, can be used to trace back to the source code</p>
</li>
<li>
<p>used for early optimizations</p>
</li>
<li>
<p>example:</p>
<p><img src="ast.png" alt="Abstract Syntax Tree (AST) - type of a mid-level IR
credits: GeeksForGeeks"></p>
<p>Abstract Syntax Tree (AST) - type of a mid-level IR
credits: GeeksForGeeks</p>
</li>
</ul>
</li>
<li>
<p>mid-level - ex: TAC Three address code</p>
<ul>
<li>
<p>Ex. T1 = T2 op A</p>
</li>
<li>
<p>has maximum of three operands</p>
</li>
<li>
<p>uses temprories (eg: T1)</p>
</li>
<li>
<p>The typical form of a three address statement is expressed as <em>x = y op z</em>, where <em>x, y</em>, and <em>z</em> represent memory addresses.</p>
</li>
<li>
<p>ex: x = (a + b * c) / (a - b * c)</p>
<p>t1 = b * c
t2 = a + t1
t3 = a - t1
x  = t2 / t3</p>
<p>Did you notice the reusable t1? Yes, optimization.</p>
</li>
</ul>
</li>
<li>
<p>low-level - ex: Register Transfer Language or LLVM</p>
<ul>
<li>
<p>stack based - ex: Java bytecode or CPython bytecode</p>
<ul>
<li>it is also mid-lower level IR</li>
<li>stack based</li>
<li>replicates a stack</li>
<li>features:
<ul>
<li>no named registers</li>
<li>everything flows through stack</li>
</ul>
</li>
</ul>
</li>
<li>
<p>closer to machine-code</p>
</li>
<li>
<p>register based</p>
</li>
<li>
<p>has memory accesses and registers</p>
</li>
<li>
<p>unlimited temp (Ex. T1…) values</p>
</li>
<li>
<p>made for heavy optimizations</p>
</li>
<li>
<p>does not contain irrelevant syntaxes</p>
</li>
<li>
<p>example</p>
<p>→ code : C++</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum</span> (<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>→ IR : LLVM format</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span><span style="color:#66d9ef">define</span> <span style="color:#66d9ef">i32</span> @sum (<span style="color:#66d9ef">i32</span> %a, <span style="color:#66d9ef">i32</span> %b){
</span></span><span style="display:flex;"><span>	%1 = <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">i32</span> %a, %b
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">ret</span> <span style="color:#66d9ef">i32</span> %1
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>we can see that even though there was no variable defined in the actual code, in LLVM format, there is a <code>%1</code> temp created and that is returned.</li>
<li>other thing that we can notice is how we add the two i32 integers.
<ol>
<li>first we write <strong>add</strong> and then the two references.</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Many compilers use multiple levels: high-level (tree-like) → mid (SSA) → low (register-based).</p>
</li>
</ul>
<hr>
<p>One question often asked is this. Why IR? Why not just take the source code and execute that directly?</p>
<p>Glad you asked.</p>
<p>It’s because IR’s help in optimizations. They form the last part of the front-end of compilation process. You can make any sort of optimizations: constant folding, loop unrolling, inlining, etc.</p>
<p>What we’ve seen so far is how your code goes from source code level, to an IR (that is close to being a foreign language to us).</p>
<p>Ex: Java (via javac) → JVM Bytecode, C++ → via Clang compiler → LLVM IR</p>
<ul>
<li>(gcc has its own IR of c++ code that is RTL)</li>
</ul>
<p>Let’s see now how that IR is translated into machine code.</p>
<p>But before that,</p>
<ul>
<li>
<p>Little case study on JVM bytecode and LLVM IR</p>
<p>we will see how this function below</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add</span> (<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>turns into IR of Java and C++ (via Clang)</p>
<p><img src="image.png" alt="image.png"></p>
</li>
</ul>
<p>a lot of things happen when we move to the final step from IR to machine code!</p>
<h3 id="from-ir-to-machine-code-pipeline-in-rough-phases">From IR to Machine code: pipeline (in rough phases)</h3>
<ol>
<li>
<p>IR optimization:</p>
<ol>
<li>remove unnecessary functions/variables/ops</li>
<li>do all the (2+3)s to 5s</li>
<li><strong>inline:</strong> expand functions</li>
</ol>
</li>
<li>
<p>convert to lower level, architecture aware form</p>
<ul>
<li>GCC GIMPLE (IR) → RTL</li>
<li>LLVM (IR) → MachineIR</li>
</ul>
<ol>
<li>Example: Stack-based IR (JVM bytecode) gets &ldquo;de-stacked&rdquo; into register form for JIT.</li>
</ol>
</li>
<li>
<p>now this is my favourite part:</p>
<p>mapping of IR functions to CPU operations happen here.</p>
<p>and different architectures have different forms of the same instructions.</p>
<p>Here’s what I mean:</p>
<ul>
<li>say you have a <em>add i32.</em> this is basically <em>add int.</em></li>
<li>in x86 CPUs → ADD reg, reg</li>
<li>in ARM CPUs → ADD rd, rn, rm</li>
<li>here’s a small comparison table (highly recommended to check out!)
<table>
  <thead>
      <tr>
          <th>IR Op</th>
          <th>x86 Instruction</th>
          <th>ARM Instruction</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>add i32</td>
          <td>ADD reg, reg</td>
          <td>ADD rd, rn, rm</td>
      </tr>
      <tr>
          <td>load i32</td>
          <td>MOV reg, [mem]</td>
          <td>LDR rd, [rn]</td>
      </tr>
      <tr>
          <td>branch</td>
          <td>JMP / Jcc</td>
          <td>B / B.cond</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Register allocation: uses algorithm “<strong>Graph Coloring</strong>”</p>
<ul>
<li>registers - fast, memory - slow.</li>
<li>if there are extra variables then spill one to stack, use it later.</li>
</ul>
</li>
<li>
<p>Scheduling and tweaks</p>
<ul>
<li>schedule instructions. meaning the instructions used majorly are called first</li>
<li>small tweaks like <strong>add i32 %a, 1</strong> → <strong>inc i32 %a</strong></li>
</ul>
</li>
<li>
<p>Code Emission &amp; Linking
Output assembly or object file is formed (e.g., .o file), then link to executable.</p>
<ul>
<li>Assemble: Text asm → binary (opcodes + operands).</li>
<li>Link: Resolve externals, add runtime (e.g., libc).
Example: Final x86 machine code for simple <strong>add</strong>: <strong>55 48 89 E5 89 7D FC 89 75 F8 8B 55 FC 8B 45 F8 01 D0 5D C3</strong> (prologue + add + epilogue).</li>
</ul>
</li>
</ol>
<h2 id="machine-code">Machine Code</h2>
<blockquote>
<p>it is the lowest level representation of code.</p>
</blockquote>
<blockquote>
<p>it is <strong>architecture dependent</strong>. Put simply, to make a compiler, you’d need to know the type of CPU the code will be executed on.</p>
</blockquote>
<blockquote>
<p>everything in machine code is “out there”. Meaning, the registers information, jumps, memory addresses etc. No abstractions.</p>
</blockquote>
<blockquote>
<p>it has</p>
</blockquote>
<ul>
<li>opcode - ex: add, jump</li>
<li>registers - ex: EAX on x86 architecture</li>
<li>memory operands - addresses for load/store</li>
<li>immediates - constants embedded in instructions.</li>
</ul>
<blockquote>
<blockquote>
<p>this has “unlimited” IR virtual registers (ex %1, %2..)</p>
</blockquote>
</blockquote>
<p>And there we have it.</p>
<p>here’s something for a review.</p>
<p><img src="gfg-compiler-phases.png" alt="Picture source: geeksforgeeks.org"></p>
<p>Picture source: geeksforgeeks.org</p>
<p>From language specific details, check out the <a href="https://medium.com/javarevisited/code-compilation-from-source-to-machine-code-1375e49d00b6">https://medium.com/javarevisited/code-compilation-from-source-to-machine-code-1375e49d00b6</a> article.</p>
<p>~ Aayushya Tiwari</p>
<h1 id="references">References</h1>
<p><a href="https://www.geeksforgeeks.org/compiler-design/intermediate-code-generation-in-compiler-design/">GFG on Intermediate Code Generation</a></p>
<p><a href="https://www.geeksforgeeks.org/compiler-design/three-address-code-compiler/">GFG on TAC</a></p>
<p><a href="https://medium.com/javarevisited/code-compilation-from-source-to-machine-code-1375e49d00b6">Brilliant essay on how Java, C++ and Python compile code</a></p>
<p><a href="https://net-informations.com/python/iq/linking.htm">article on how python code is compiled</a></p>
<p><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">wiki on ASTs</a></p>
<p>LLMs: grok.com, chatgpt.com</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  AAYUSHYA TIWARI 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
